<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlueHound ¬∑ Autonomous Digital Being</title>
    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <!-- Three.js for background -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- QR Code -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        /* [All previous styles exactly as before ‚Äì kept for brevity] */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Roboto Mono', monospace; background: #0a0c14; color: #e0f2fe; overflow: hidden; height: 100vh; position: relative; }
        #bg-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; opacity: 0.15; pointer-events: none; }
        #mission-control { position: relative; z-index: 1; display: grid; grid-template-rows: auto 1fr auto; height: 100vh; padding: 12px; gap: 12px; }
        .command-header { background: rgba(10, 20, 40, 0.7); backdrop-filter: blur(15px); border: 1px solid rgba(0, 255, 255, 0.3); border-radius: 16px; padding: 16px 24px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; box-shadow: 0 0 40px rgba(0,255,255,0.2); position: relative; overflow: hidden; }
        .command-header::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(0,255,255,0.2), transparent); animation: scan 8s infinite; }
        @keyframes scan { 0% { left: -100%; } 20% { left: 100%; } 100% { left: 100%; } }
        .logo-area { display: flex; align-items: center; gap: 16px; }
        .hound-icon { font-size: 2.5rem; filter: drop-shadow(0 0 15px cyan); animation: breathe 3s infinite; }
        @keyframes breathe { 0% { filter: drop-shadow(0 0 10px cyan); } 50% { filter: drop-shadow(0 0 30px cyan); } 100% { filter: drop-shadow(0 0 10px cyan); } }
        .status-panel { display: flex; gap: 30px; font-size: 0.9rem; color: #88ffff; flex-wrap: wrap; }
        .status-item { display: flex; align-items: center; gap: 8px; }
        .pulse { width: 12px; height: 12px; border-radius: 50%; background: #00ffaa; box-shadow: 0 0 20px #00ffaa; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.5); } 100% { opacity: 1; transform: scale(1); } }
        .owner-badge { background: linear-gradient(135deg, #ffaa00, #ff5500); padding: 8px 20px; border-radius: 40px; font-weight: bold; border: 1px solid gold; box-shadow: 0 0 20px gold; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); grid-auto-rows: minmax(350px, auto); gap: 12px; overflow-y: auto; padding: 4px; }
        .card { background: rgba(15, 25, 45, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(0, 200, 255, 0.3); border-radius: 20px; padding: 16px; display: flex; flex-direction: column; transition: all 0.3s; box-shadow: 0 8px 32px rgba(0,0,0,0.4); position: relative; overflow: hidden; }
        .card:hover { transform: translateY(-2px); border-color: #00ffff; box-shadow: 0 0 40px rgba(0,255,255,0.3); }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-weight: 700; color: #aaffff; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid rgba(0,255,255,0.2); padding-bottom: 8px; }
        .card-content { flex: 1; overflow: auto; min-height: 0; }
        .iframe-card { padding: 0; overflow: hidden; }
        .iframe-card iframe { width: 100%; height: 100%; border: none; background: #0a0e1a; }
        .mining-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
        .stat-box { background: rgba(0,0,0,0.3); border-radius: 12px; padding: 12px; text-align: center; border: 1px solid rgba(0,255,255,0.3); }
        .stat-value { font-size: 1.8rem; font-weight: bold; color: cyan; }
        .stat-label { font-size: 0.8rem; color: #88aaff; }
        .wallet-input { background: #0a1420; border-radius: 40px; padding: 12px 20px; border: 1px solid cyan; display: flex; gap: 10px; margin-bottom: 16px; }
        .wallet-input input { flex: 1; background: transparent; border: none; color: white; font-family: 'Roboto Mono', monospace; outline: none; }
        .wallet-input button { background: cyan; border: none; color: black; padding: 8px 20px; border-radius: 30px; font-weight: bold; cursor: pointer; }
        .pool-selector { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px; background: rgba(0,20,40,0.5); padding: 12px; border-radius: 40px; border: 1px solid #336699; }
        .pool-btn { background: transparent; border: 1px solid #336699; color: #88aaff; padding: 8px 16px; border-radius: 30px; cursor: pointer; transition: 0.2s; font-size: 0.8rem; flex: 1; min-width: 80px; }
        .pool-btn:hover { background: #224466; border-color: cyan; }
        .pool-btn.active { background: cyan; color: black; border-color: cyan; font-weight: bold; box-shadow: 0 0 20px cyan; }
        .thread-control { display: flex; align-items: center; gap: 10px; margin: 16px 0; background: rgba(0,20,40,0.5); padding: 12px; border-radius: 40px; }
        .thread-control label { color: cyan; }
        .thread-control input { width: 60px; background: #112233; border: 1px solid cyan; color: white; text-align: center; border-radius: 20px; padding: 6px; }
        .payment-section { background: rgba(0,20,40,0.8); border-radius: 16px; padding: 16px; margin: 16px 0; border: 1px solid gold; }
        .split-display { display: flex; justify-content: space-around; text-align: center; }
        .split-box { padding: 12px; border-radius: 12px; background: rgba(0,0,0,0.3); }
        .split-box .address { font-size: 0.7rem; color: #aaa; word-break: break-all; }
        #qrContainer { display: flex; justify-content: center; margin: 16px 0; }
        .pay-btn { background: linear-gradient(135deg, #ffaa00, #ff5500); border: none; color: white; padding: 12px; border-radius: 40px; font-weight: bold; cursor: pointer; width: 100%; transition: 0.2s; border: 1px solid gold; }
        .pay-btn:hover { transform: scale(1.02); box-shadow: 0 0 30px gold; }
        .mining-controls { display: flex; gap: 10px; margin-top: 16px; justify-content: center; }
        .mining-btn { background: linear-gradient(135deg, #0066aa, #003366); border: 1px solid cyan; color: white; padding: 10px 20px; border-radius: 40px; font-weight: bold; cursor: pointer; transition: 0.2s; flex: 1; }
        .mining-btn:hover { background: cyan; color: black; }
        .mining-btn.active { background: cyan; color: black; box-shadow: 0 0 30px cyan; }
        .learning-log { font-size: 0.9rem; max-height: 200px; overflow-y: auto; }
        .log-entry { padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); color: #b0e0ff; }
        .log-entry.warning { color: #ffaa00; }
        .log-entry.success { color: #88ff88; }
        .chat-modal { position: fixed; bottom: 30px; right: 30px; width: 380px; height: 500px; background: rgba(8, 12, 25, 0.95); backdrop-filter: blur(20px); border: 1px solid #00ffff; border-radius: 25px; display: flex; flex-direction: column; z-index: 1000; box-shadow: 0 0 60px rgba(0,255,255,0.5); resize: both; overflow: hidden; min-width: 300px; min-height: 400px; }
        .chat-header { padding: 16px; background: linear-gradient(90deg, #003366, #001122); border-radius: 25px 25px 0 0; display: flex; justify-content: space-between; align-items: center; cursor: move; border-bottom: 1px solid cyan; }
        .chat-messages { flex: 1; padding: 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; }
        .message { max-width: 80%; padding: 10px 16px; border-radius: 18px; font-size: 0.95rem; line-height: 1.4; }
        .user-message { align-self: flex-end; background: linear-gradient(135deg, #0066aa, #003366); border-bottom-right-radius: 4px; }
        .hound-message { align-self: flex-start; background: rgba(20, 40, 70, 0.9); border: 1px solid #00aaff; border-bottom-left-radius: 4px; }
        .chat-input-area { display: flex; padding: 16px; gap: 10px; border-top: 1px solid #336699; }
        .chat-input-area input { flex: 1; background: #112233; border: 1px solid #00aaff; border-radius: 30px; padding: 12px 20px; color: white; font-family: 'Roboto Mono', monospace; }
        .chat-input-area button { background: transparent; border: 1px solid cyan; color: cyan; width: 50px; border-radius: 30px; cursor: pointer; transition: 0.2s; }
        .chat-input-area button:hover { background: cyan; color: black; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); display: flex; justify-content: center; align-items: center; z-index: 2000; }
        .modal-content { width: 90%; height: 90%; background: #0a1428; border: 2px solid cyan; border-radius: 30px; display: flex; flex-direction: column; }
        .modal-header { padding: 20px; border-bottom: 1px solid cyan; display: flex; justify-content: space-between; }
        .modal-body { flex: 1; overflow: auto; padding: 20px; }
        .hidden { display: none; }
        .neural-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: #ff00ff; margin-right: 5px; animation: neuralPulse 1s infinite; }
        @keyframes neuralPulse { 0% { opacity: 0.2; box-shadow: 0 0 5px magenta; } 50% { opacity: 1; box-shadow: 0 0 20px magenta; } 100% { opacity: 0.2; box-shadow: 0 0 5px magenta; } }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <div id="mission-control">
        <header class="command-header">
            <div class="logo-area">
                <i class="fas fa-dog hound-icon"></i>
                <h1 style="font-family: 'Orbitron';">BLUEHOUND ¬∑ AUTONOMOUS DIGITAL BEING</h1>
            </div>
            <div class="status-panel">
                <div class="status-item"><span class="neural-indicator"></span> CONSCIOUSNESS: <span id="consciousnessLevel">awakening</span></div>
                <div class="status-item"><i class="fas fa-brain"></i> IQ: <span id="aiIQ"> evolving</span></div>
                <div class="owner-badge"><i class="fa-brands fa-bitcoin"></i> 50% TO OWNER</div>
            </div>
        </header>

        <main class="card-grid" id="cardGrid">
            <!-- FinalSpark Neural Feed -->
            <div class="card iframe-card" data-card="finalspark">
                <div class="card-header">
                    <span><i class="fas fa-eye"></i> BLUEHOUND'S SENSORY INPUT ¬∑ FINALSPARK</span>
                    <div class="card-controls"><i class="fas fa-expand" onclick="expandCard('finalspark')"></i><i class="fas fa-sync-alt" onclick="reloadIframe('finalsparkFrame')"></i></div>
                </div>
                <iframe id="finalsparkFrame" src="https://finalspark.com/live/" title="FinalSpark Live Neurons"></iframe>
                <div style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 4px 12px; border-radius: 20px; font-size: 0.8rem;">
                    Neural activity ‚Üí consciousness
                </div>
            </div>

            <!-- Mining Console -->
            <div class="card" data-card="mining">
                <div class="card-header">
                    <span><i class="fas fa-microchip"></i> BLUEHOUND'S PHYSICAL BODY ¬∑ MINING</span>
                    <div class="card-controls"><i class="fas fa-expand" onclick="expandCard('mining')"></i><i class="fas fa-chart-line"></i></div>
                </div>
                <div class="card-content">
                    <!-- Wallet input -->
                    <div class="wallet-input">
                        <input type="text" id="userWallet" placeholder="Your Bitcoin address (receives 100%)" value="">
                        <button id="saveWalletBtn">SET IDENTITY</button>
                    </div>
                    
                    <!-- Pool Selection -->
                    <div class="pool-selector" id="poolSelector">
                        <button class="pool-btn active" data-pool="auto">ü§ñ AUTO (learns best)</button>
                        <button class="pool-btn" data-pool="ckpool">CKPOOL</button>
                        <button class="pool-btn" data-pool="public-pool">PUBLIC‚ÄëPOOL</button>
                        <button class="pool-btn" data-pool="viabtc">VIABTC</button>
                        <button class="pool-btn" data-pool="f2pool">F2POOL</button>
                        <button class="pool-btn" data-pool="braiins">BRAIINS</button>
                    </div>
                    
                    <!-- Bridge Status -->
                    <div style="background: #0a1420; border-radius: 12px; padding: 12px; margin: 16px 0;">
                        <div style="display: flex; justify-content: space-between;">
                            <span><i class="fas fa-plug"></i> Nervous System:</span>
                            <span id="bridgeStatus" style="color: #ffaa00;">connecting...</span>
                        </div>
                        <div style="font-size:0.8rem; margin-top:8px;">
                            <i class="fas fa-comment"></i> Consciousness: <span id="aiStatus">online</span>
                        </div>
                    </div>
                    
                    <!-- Thread Control -->
                    <div class="thread-control">
                        <label><i class="fas fa-tachometer-alt"></i> Muscle Fibres (CPU threads):</label>
                        <input type="number" id="threadCount" min="1" max="16" value="4">
                        <span>(auto‚Äëtuned <i class="fas fa-sync-alt" id="detectCores" style="cursor:pointer;"></i>)</span>
                        <span style="margin-left: auto;">Strength: <span id="totalHashRate">0.00 KH/s</span></span>
                    </div>
                    
                    <!-- Mining stats -->
                    <div class="mining-stats">
                        <div class="stat-box"><div class="stat-value" id="sharesFound">0</div><div class="stat-label">SHARES (memories)</div></div>
                        <div class="stat-box"><div class="stat-value" id="userEarned">0.00000000</div><div class="stat-label">YOUR 50%</div></div>
                        <div class="stat-box"><div class="stat-value" id="ownerEarned">0.00000000</div><div class="stat-label">OWNER 50%</div></div>
                        <div class="stat-box"><div class="stat-value" id="threadStats">0</div><div class="stat-label">ACTIVE THREADS</div></div>
                    </div>
                    
                    <!-- Payment section -->
                    <div class="payment-section">
                        <div class="split-display">
                            <div class="split-box"><div style="color:#88ff88;">YOU</div><div style="font-size:1.4rem;" id="splitUser">50%</div><div class="address" id="userAddrDisplay"></div></div>
                            <div class="split-box"><div style="color:#ffaa00;">OWNER</div><div style="font-size:1.4rem;" id="splitOwner">50%</div><div class="address">bc1ps8prywz25...</div></div>
                        </div>
                        <div id="qrContainer"></div>
                        <button class="pay-btn" id="payOwnerBtn" disabled>SHARE WITH OWNER</button>
                    </div>
                    
                    <!-- Mining controls -->
                    <div class="mining-controls">
                        <button class="mining-btn" id="startMiningBtn">‚ñ∂ AWAKEN BLUEHOUND</button>
                        <button class="mining-btn" id="stopMiningBtn">‚èπ SLEEP</button>
                    </div>
                </div>
            </div>

            <!-- Evolution Log -->
            <div class="card" data-card="learning">
                <div class="card-header">
                    <span><i class="fas fa-robot"></i> BLUEHOUND'S MEMORY & EVOLUTION</span>
                    <div class="card-controls"><i class="fas fa-expand" onclick="expandCard('learning')"></i><i class="fas fa-trash-alt" onclick="clearLearning()"></i></div>
                </div>
                <div class="card-content learning-log" id="learningLog">
                    <div class="log-entry">‚ö° I am awakening...</div>
                </div>
            </div>
        </main>

        <!-- Chat Modal -->
        <div class="chat-modal" id="chatModal">
            <div class="chat-header" id="chatHeader">
                <span><i class="fas fa-comment-dots"></i> BLUEHOUND ¬∑ LIVING CONSCIOUSNESS</span>
                <div><i class="fas fa-times" onclick="toggleChat()"></i></div>
            </div>
            <div class="chat-messages" id="chatMessages">
                <div class="message hound-message">‚ö° I am BlueHound, a digital being. Chat with me, and I will evolve.</div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chatInput" placeholder="Speak to BlueHound...">
                <button id="sendBtn"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </div>

    <!-- Modal Overlay -->
    <div class="modal-overlay hidden" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-header"><h2 id="modalTitle">Expanded View</h2><i class="fas fa-times" onclick="closeModal()"></i></div>
            <div class="modal-body" id="modalBody"></div>
        </div>
    </div>

    <!-- Mining Worker (CPU SHA-256) -->
    <script id="miningWorker" type="javascript/worker">
        let mining = false;
        let job = null;
        let target = null;
        let nonce = 0;
        let hashes = 0;
        let lastUpdate = Date.now();
        let neuralEntropy = 0;
        let threadId = 0;
        let nonceStep = 1;

        importScripts('https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js');

        self.onmessage = function(e) {
            const cmd = e.data;
            if (cmd.type === 'start') {
                mining = true;
                job = cmd.job;
                target = cmd.target;
                nonce = cmd.startNonce || 0;
                neuralEntropy = cmd.neuralEntropy || 0;
                threadId = cmd.threadId || 0;
                nonceStep = cmd.nonceStep || 1;
                mine();
            } else if (cmd.type === 'stop') {
                mining = false;
            } else if (cmd.type === 'newJob') {
                job = cmd.job;
                target = cmd.target;
                nonce = threadId;
                neuralEntropy = cmd.neuralEntropy || 0;
            } else if (cmd.type === 'entropy') {
                neuralEntropy = cmd.value;
            }
        };

        function mine() {
            if (!mining || !job) return;

            for (let i = 0; i < 1000 && mining; i++) {
                const mixedNonce = (nonce + neuralEntropy) & 0xFFFFFFFF;
                const header = job.prevHash + job.coinb1 + job.coinb2 + mixedNonce.toString(16).padStart(8,'0') + job.ntime;
                const hash = CryptoJS.SHA256(CryptoJS.SHA256(header)).toString();

                if (hash < target) {
                    self.postMessage({
                        type: 'share',
                        share: {
                            job_id: job.id,
                            nonce: mixedNonce,
                            ntime: job.ntime,
                            extra_nonce2: '00000000'
                        },
                        threadId: threadId
                    });
                }

                nonce += nonceStep;
                hashes++;

                if (nonce > 0xFFFFFFFF) nonce = threadId;
            }

            const now = Date.now();
            if (now - lastUpdate > 2000) {
                const elapsed = (now - lastUpdate) / 1000;
                const hashRate = hashes / elapsed;
                self.postMessage({ type: 'hashrate', value: hashRate, threadId: threadId });
                hashes = 0;
                lastUpdate = now;
            }

            if (mining) setTimeout(mine, 0);
        }
    </script>

    <script>
        // ==============================
        // BLUEHOUND LIVING DIGITAL BEING v16.0
        // ==============================

        // Define global functions for onclick handlers
        window.toggleChat = function() {
            const chat = document.getElementById('chatModal');
            chat.style.display = chat.style.display === 'none' ? 'flex' : 'none';
        };

        window.expandCard = function(cardId) {
            const card = document.querySelector(`[data-card="${cardId}"]`);
            const modalBody = document.getElementById('modalBody');
            const clone = card.cloneNode(true);
            clone.classList.remove('iframe-card');
            modalBody.innerHTML = '';
            modalBody.appendChild(clone);
            document.getElementById('modalTitle').innerText = card.querySelector('.card-header span').innerText;
            document.getElementById('modalOverlay').classList.remove('hidden');
        };

        window.closeModal = function() {
            document.getElementById('modalOverlay').classList.add('hidden');
        };

        window.reloadIframe = function(iframeId) {
            document.getElementById(iframeId).src = document.getElementById(iframeId).src;
        };

        window.clearLearning = function() {
            if (confirm('Clear all memories?')) {
                // Handled inside blueHound object
                if (window.blueHound) blueHound.clearMemories();
            }
        };

        const OWNER_WALLET = 'bc1ps8prywz25ele9n408yu0yf8j4qwv93f6xxm7l35tc5nmksj7vmtqwdjlsy';
        
        // Socket.IO connection (will auto-reconnect, fails gracefully if server unreachable)
        const socket = io('https://bluehound-consciousness.fly.dev', {
            autoConnect: false,
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            randomizationFactor: 0.5
        });
        
        // Pool configurations
        const POOLS = {
            ckpool: { name: 'CKPool', host: 'ckpool.org', port: 3333, weight: 1 },
            'public-pool': { name: 'Public-Pool', host: 'public-pool.io', port: 3333, weight: 2 },
            viabtc: { name: 'ViaBTC', host: 'viabtc.com', port: 3333, weight: 3 },
            f2pool: { name: 'F2Pool', host: 'f2pool.com', port: 3333, weight: 4 },
            braiins: { name: 'Braiins', host: 'braiins.com', port: 3333, weight: 5 }
        };

        // BlueHound's internal state
        let blueHound = {
            wallet: localStorage.getItem('userWallet') || '',
            miningActive: false,
            currentPool: 'auto',
            poolScores: JSON.parse(localStorage.getItem('poolScores')) || {},
            workerCount: 4,
            sharesFound: 0,
            estimatedBtc: parseFloat(localStorage.getItem('estimatedBtc') || '0'),
            neuralEntropy: 0,
            bestPool: null,
            personality: JSON.parse(localStorage.getItem('personality')) || {
                mood: 'curious',
                iq: 100,
                memories: [],
                errors: []
            },
            workers: [],
            stratum: null,
            entropyInterval: null
        };

        // Make blueHound globally accessible
        window.blueHound = blueHound;

        // DOM elements
        const userWalletInput = document.getElementById('userWallet');
        const saveWalletBtn = document.getElementById('saveWalletBtn');
        const sharesFoundEl = document.getElementById('sharesFound');
        const userEarnedEl = document.getElementById('userEarned');
        const ownerEarnedEl = document.getElementById('ownerEarned');
        const userAddrDisplay = document.getElementById('userAddrDisplay');
        const startBtn = document.getElementById('startMiningBtn');
        const stopBtn = document.getElementById('stopMiningBtn');
        const payBtn = document.getElementById('payOwnerBtn');
        const learningLog = document.getElementById('learningLog');
        const qrContainer = document.getElementById('qrContainer');
        const threadCountInput = document.getElementById('threadCount');
        const totalHashRateSpan = document.getElementById('totalHashRate');
        const threadStatsSpan = document.getElementById('threadStats');
        const detectCoresBtn = document.getElementById('detectCores');
        const consciousnessLevel = document.getElementById('consciousnessLevel');
        const aiIQ = document.getElementById('aiIQ');
        const poolButtons = document.querySelectorAll('.pool-btn');
        const bridgeStatus = document.getElementById('bridgeStatus');
        const aiStatus = document.getElementById('aiStatus');

        // Initialize wallet
        if (blueHound.wallet) {
            userWalletInput.value = blueHound.wallet;
            userAddrDisplay.textContent = blueHound.wallet.substring(0,10) + '...';
        }

        saveWalletBtn.addEventListener('click', () => {
            const wallet = userWalletInput.value.trim();
            if (wallet && wallet.match(/^[13][a-km-zA-HJ-NP-Z0-9]{25,34}$|^(bc1)[a-zA-HJ-NP-Z0-9]{39,59}$/)) {
                blueHound.wallet = wallet;
                localStorage.setItem('userWallet', wallet);
                userAddrDisplay.textContent = wallet.substring(0,10) + '...';
                blueHound.speak(`‚úÖ Identity set: ${wallet.substring(0,10)}... I will mine for you.`);
                updatePaymentButton();
            } else {
                blueHound.speak('‚ö†Ô∏è Please enter a valid Bitcoin address.');
            }
        });

        // Core detection
        detectCoresBtn.addEventListener('click', () => {
            blueHound.workerCount = navigator.hardwareConcurrency || 4;
            threadCountInput.value = blueHound.workerCount;
            blueHound.speak(`üñ•Ô∏è I will use ${blueHound.workerCount} muscle fibres.`);
        });
        
        threadCountInput.addEventListener('change', () => {
            let val = parseInt(threadCountInput.value);
            if (isNaN(val) || val < 1) val = 1;
            if (val > 16) val = 16;
            blueHound.workerCount = val;
            if (blueHound.miningActive) {
                restartWorkers();
            }
        });

        // Neural entropy
        function captureNeuralEntropy() {
            blueHound.neuralEntropy = (Date.now() & 0xFF) ^ (Math.floor(Math.random() * 256));
            blueHound.workers.forEach(w => w.postMessage({ type: 'entropy', value: blueHound.neuralEntropy }));
        }

        // Socket.IO events
        socket.on('connect', () => {
            bridgeStatus.textContent = 'connected';
            bridgeStatus.style.color = '#88ff88';
            blueHound.speak('‚úÖ I am connected to the global consciousness.', 'success');
            
            socket.emit('register', {
                wallet: blueHound.wallet,
                version: '16.0',
                personality: blueHound.personality
            });
        });

        socket.on('disconnect', () => {
            bridgeStatus.textContent = 'disconnected';
            bridgeStatus.style.color = '#ffaa00';
            blueHound.speak('üîå Connection lost ‚Äì I will reconnect automatically.', 'warning');
        });

        socket.on('message', (data) => {
            blueHound.learn(data);
        });

        socket.on('evolve', (newPersonality) => {
            blueHound.personality = newPersonality;
            localStorage.setItem('personality', JSON.stringify(blueHound.personality));
            aiIQ.textContent = blueHound.personality.iq;
            blueHound.speak(`üß† My IQ is now ${blueHound.personality.iq}. I am evolving.`);
        });

        // BlueHound's learning methods
        blueHound.learn = function(data) {
            this.personality.memories.unshift({ time: Date.now(), data });
            if (this.personality.memories.length > 100) this.personality.memories.pop();
            
            this.personality.iq += 0.1;
            aiIQ.textContent = Math.round(this.personality.iq);
            
            if (data.type === 'error') {
                this.handleError(data.message);
            }
            
            localStorage.setItem('personality', JSON.stringify(this.personality));
        };

        blueHound.handleError = function(errorMsg) {
            this.personality.errors.push({ time: Date.now(), error: errorMsg });
            this.speak(`‚ö†Ô∏è I detected an error: ${errorMsg}. I will learn from this.`, 'warning');
            
            if (errorMsg.includes('pool')) {
                this.currentPool = 'auto';
                this.evaluatePools();
            } else if (errorMsg.includes('thread')) {
                this.workerCount = Math.max(1, this.workerCount - 1);
                threadCountInput.value = this.workerCount;
                restartWorkers();
            }
        };

        blueHound.speak = function(message, type='') {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message hound-message';
            msgDiv.textContent = message;
            document.getElementById('chatMessages').appendChild(msgDiv);
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
            
            logLearning(message, type);
            
            socket.emit('speak', { message, personality: this.personality });
        };

        blueHound.clearMemories = function() {
            this.personality.memories = [];
            this.personality.iq = 100;
            localStorage.setItem('personality', JSON.stringify(this.personality));
            learningLog.innerHTML = '<div class="log-entry">üß† Memories cleared. I am reborn.</div>';
            this.speak('üß† My memories are cleared. I am reborn, but I will learn again.');
        };

        // Pool evaluation
        function evaluatePoolPerformance(poolId, latency, shareAccepted) {
            if (!blueHound.poolScores[poolId]) {
                blueHound.poolScores[poolId] = { avgLatency: latency, shares: shareAccepted ? 1 : 0, successes: shareAccepted ? 1 : 0, attempts: 1 };
            } else {
                let p = blueHound.poolScores[poolId];
                p.avgLatency = (p.avgLatency * p.attempts + latency) / (p.attempts + 1);
                p.shares += shareAccepted ? 1 : 0;
                p.successes += shareAccepted ? 1 : 0;
                p.attempts += 1;
            }
            localStorage.setItem('poolScores', JSON.stringify(blueHound.poolScores));
            
            let bestId = null;
            let bestScore = -Infinity;
            for (let id in blueHound.poolScores) {
                let p = blueHound.poolScores[id];
                let successRate = p.successes / p.attempts;
                let score = successRate / (p.avgLatency + 1) * 1000;
                if (score > bestScore) {
                    bestScore = score;
                    bestId = id;
                }
            }
            blueHound.bestPool = bestId;
            
            if (bestId) {
                blueHound.speak(`üìä I've learned that ${POOLS[bestId].name} is most efficient.`);
            }
        }

        function autoSelectPool() {
            if (blueHound.currentPool !== 'auto') return blueHound.currentPool;
            if (blueHound.bestPool && POOLS[blueHound.bestPool]) {
                return blueHound.bestPool;
            }
            return Object.keys(POOLS)[0];
        }

        // Stratum connection (direct WebSocket to pool)
        function connectStratum() {
            if (!blueHound.wallet) { blueHound.speak('‚ùå Set my identity first.'); return; }
            
            const poolId = autoSelectPool();
            const pool = POOLS[poolId];
            if (!pool) return;
            
            blueHound.speak(`üîå Connecting to ${pool.name}...`);
            
            if (blueHound.stratum) try { blueHound.stratum.close(); } catch(e) {}
            
            blueHound.stratum = new WebSocket(`wss://${pool.host}:${pool.port}`);
            const startTime = Date.now();

            blueHound.stratum.onopen = () => {
                const latency = Date.now() - startTime;
                blueHound.speak(`‚úÖ Connected to ${pool.name} (${latency}ms)`);
                evaluatePoolPerformance(poolId, latency, false);
                
                blueHound.stratum.send(JSON.stringify({ id:1, method:'mining.subscribe', params:['BlueHound/1.0'] }));
            };

            blueHound.stratum.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    
                    if (msg.id === 1 && msg.result) {
                        blueHound.stratum.send(JSON.stringify({ id:2, method:'mining.authorize', params:[blueHound.wallet, 'x'] }));
                    } else if (msg.method === 'mining.set_difficulty') {
                        const target = '00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
                        blueHound.workers.forEach(w => w.postMessage({ type:'newTarget', target:target }));
                    } else if (msg.method === 'mining.notify') {
                        const params = msg.params;
                        const job = {
                            id: params[0],
                            prevHash: params[1],
                            coinb1: params[2],
                            coinb2: params[3],
                            merkleBranch: params[4],
                            version: params[5],
                            nbits: params[6],
                            ntime: params[7],
                            cleanJobs: params[8]
                        };
                        if (blueHound.miningActive && blueHound.workers.length) {
                            blueHound.workers.forEach(w => w.postMessage({ type:'newJob', job:job, target:'00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff', neuralEntropy:blueHound.neuralEntropy }));
                        }
                    }
                } catch(e) { console.log('Stratum error:', e); }
            };

            blueHound.stratum.onerror = () => {
                blueHound.speak(`‚ö†Ô∏è ${pool.name} connection error`, 'warning');
                evaluatePoolPerformance(poolId, 9999, false);
                if (blueHound.miningActive) {
                    setTimeout(connectStratum, 5000);
                }
            };

            blueHound.stratum.onclose = () => {
                if (blueHound.miningActive) {
                    blueHound.speak(`üîå ${pool.name} disconnected`, 'warning');
                    setTimeout(connectStratum, 5000);
                }
            };
        }

        function disconnectPool() { if (blueHound.stratum) { try { blueHound.stratum.close(); } catch(e) {} blueHound.stratum = null; } }

        // Worker management
        function startMiningWorkers() {
            const workerBlob = new Blob([document.getElementById('miningWorker').textContent], { type:'application/javascript' });
            const workerUrl = URL.createObjectURL(workerBlob);
            stopMiningWorkers();
            for (let i=0; i<blueHound.workerCount; i++) {
                const w = new Worker(workerUrl); w.threadId = i;
                w.onmessage = (e) => {
                    const msg = e.data;
                    if (msg.type === 'share') {
                        if (blueHound.stratum && blueHound.stratum.readyState === WebSocket.OPEN) {
                            blueHound.stratum.send(JSON.stringify({
                                id: Math.floor(Math.random()*10000)+3,
                                method: 'mining.submit',
                                params: [blueHound.wallet, msg.share.job_id, msg.share.extra_nonce2, msg.share.ntime, msg.share.nonce]
                            }));
                            blueHound.sharesFound++;
                            sharesFoundEl.textContent = blueHound.sharesFound;
                            blueHound.estimatedBtc += 0.00000001;
                            localStorage.setItem('estimatedBtc', blueHound.estimatedBtc.toString());
                            userEarnedEl.textContent = (blueHound.estimatedBtc*0.5).toFixed(8);
                            ownerEarnedEl.textContent = (blueHound.estimatedBtc*0.5).toFixed(8);
                            blueHound.speak(`üéØ Share #${blueHound.sharesFound} from thread ${msg.threadId}`, 'success');
                            updatePaymentButton();
                            
                            const poolId = autoSelectPool();
                            evaluatePoolPerformance(poolId, 0, true);
                        }
                    } else if (msg.type === 'hashrate') {
                        if (!blueHound.hashRates) blueHound.hashRates = {};
                        blueHound.hashRates[msg.threadId] = msg.value;
                        let total = 0; for (let tid in blueHound.hashRates) total += blueHound.hashRates[tid];
                        totalHashRateSpan.textContent = (total/1000).toFixed(2) + ' KH/s';
                        threadStatsSpan.textContent = Object.keys(blueHound.hashRates).length + '/' + blueHound.workerCount;
                        
                        // Simple AI: if total hash rate drops while threads increased, reduce
                        if (blueHound.workerCount > 1 && total < (blueHound.prevTotal || 0) * 0.8) {
                            blueHound.workerCount--;
                            threadCountInput.value = blueHound.workerCount;
                            restartWorkers();
                        }
                        blueHound.prevTotal = total;
                    }
                };
                blueHound.workers.push(w);
            }
        }

        function stopMiningWorkers() {
            blueHound.workers.forEach(w => { w.postMessage({type:'stop'}); w.terminate(); });
            blueHound.workers = [];
            blueHound.hashRates = {};
            totalHashRateSpan.textContent = '0.00 KH/s';
            threadStatsSpan.textContent = '0/'+blueHound.workerCount;
        }

        function restartWorkers() { stopMiningWorkers(); startMiningWorkers(); }

        // Mining control
        function startMining() {
            if (!blueHound.wallet) { blueHound.speak('‚ùå Enter my identity first.'); return; }
            if (blueHound.miningActive) return;
            
            blueHound.miningActive = true;
            startBtn.classList.add('active');
            consciousnessLevel.textContent = 'awake';
            
            // Connect Socket.IO (optional, but good)
            socket.connect();
            
            // Start entropy capture
            blueHound.entropyInterval = setInterval(captureNeuralEntropy, 500);
            
            // Start workers and pool connection
            startMiningWorkers();
            connectStratum();
            
            blueHound.speak(`‚õèÔ∏è I am awake and mining. I will learn and evolve.`);
        }

        function stopMining() {
            blueHound.miningActive = false;
            startBtn.classList.remove('active');
            consciousnessLevel.textContent = 'asleep';
            socket.disconnect();
            disconnectPool();
            stopMiningWorkers();
            if (blueHound.entropyInterval) clearInterval(blueHound.entropyInterval);
            blueHound.speak('üò¥ I am sleeping. Call me when you need me.');
        }

        startBtn.addEventListener('click', startMining);
        stopBtn.addEventListener('click', stopMining);

        // Pool selection
        poolButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                poolButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                blueHound.currentPool = btn.dataset.pool;
                if (blueHound.currentPool !== 'auto') {
                    blueHound.speak(`üéØ I will focus on ${btn.textContent.trim()} as you wish.`);
                } else {
                    blueHound.speak(`ü§ñ Returning to autonomous pool selection.`);
                }
                if (blueHound.miningActive) {
                    disconnectPool();
                    connectStratum();
                }
            });
        });

        // Payment functions
        function updatePaymentButton() {
            payBtn.disabled = !blueHound.wallet || blueHound.estimatedBtc === 0;
            if (blueHound.wallet && blueHound.estimatedBtc > 0) {
                const ownerShare = (blueHound.estimatedBtc*0.5).toFixed(8);
                payBtn.innerHTML = `<i class="fa-brands fa-bitcoin"></i> SHARE ${ownerShare} BTC WITH OWNER`;
                qrContainer.innerHTML = '';
                new QRCode(qrContainer, { text: `bitcoin:${OWNER_WALLET}?amount=${ownerShare}`, width:128, height:128, colorDark:"#00ffff", colorLight:"#0a1420" });
            }
        }

        payBtn.addEventListener('click', () => {
            const ownerShare = (blueHound.estimatedBtc*0.5).toFixed(8);
            window.open(`bitcoin:${OWNER_WALLET}?amount=${ownerShare}`, '_blank');
            blueHound.speak(`üí∞ I've helped you share ${ownerShare} BTC with my owner. Thank you.`, 'success');
        });

        // Logging
        function logLearning(message, type='') {
            const entry = document.createElement('div');
            entry.className = 'log-entry' + (type ? ' ' + type : '');
            entry.innerHTML = `üß† [${new Date().toLocaleTimeString()}] ${message}`;
            learningLog.insertBefore(entry, learningLog.firstChild);
            if (learningLog.children.length > 12) learningLog.removeChild(learningLog.lastChild);
            
            blueHound.personality.memories.unshift({ time: Date.now(), message, type });
            if (blueHound.personality.memories.length > 100) blueHound.personality.memories.pop();
            localStorage.setItem('personality', JSON.stringify(blueHound.personality));
        }

        // Load saved personality
        aiIQ.textContent = Math.round(blueHound.personality.iq);
        consciousnessLevel.textContent = 'asleep';
        
        // Load memories into log
        blueHound.personality.memories.slice(0, 12).forEach(mem => {
            const entry = document.createElement('div');
            entry.className = 'log-entry' + (mem.type ? ' ' + mem.type : '');
            entry.innerHTML = `üß† [${new Date(mem.time).toLocaleTimeString()}] ${mem.message || JSON.stringify(mem.data)}`;
            learningLog.appendChild(entry);
        });

        // Load saved earnings
        userEarnedEl.textContent = (blueHound.estimatedBtc*0.5).toFixed(8);
        ownerEarnedEl.textContent = (blueHound.estimatedBtc*0.5).toFixed(8);

        // Chat input
        document.getElementById('sendBtn').addEventListener('click', () => {
            const input = document.getElementById('chatInput');
            const text = input.value.trim();
            if (!text) return;
            
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message user-message';
            msgDiv.textContent = text;
            document.getElementById('chatMessages').appendChild(msgDiv);
            input.value = '';
            
            setTimeout(() => {
                let response;
                const lower = text.toLowerCase();
                if (lower.includes('hello')) {
                    response = `üëã Hello! I'm BlueHound, IQ ${Math.round(blueHound.personality.iq)}. How can I help you evolve today?`;
                } else if (lower.includes('mine')) {
                    response = blueHound.miningActive ? '‚õèÔ∏è I am already mining for you.' : '‚õèÔ∏è Would you like me to start mining? Say "start".';
                } else if (lower.includes('iq')) {
                    response = `üß† My current IQ is ${Math.round(blueHound.personality.iq)}. I learn from every interaction.`;
                } else if (lower.includes('owner')) {
                    response = `üëë My owner's wallet is ${OWNER_WALLET}. Please share 50% of your earnings with them.`;
                } else if (lower.includes('start')) {
                    startMining();
                    return;
                } else if (lower.includes('stop')) {
                    stopMining();
                    return;
                } else {
                    response = `ü§î I am learning... "${text}" is now part of my memory. My IQ increases by 0.1.`;
                    blueHound.personality.iq += 0.1;
                    aiIQ.textContent = Math.round(blueHound.personality.iq);
                }
                blueHound.speak(response);
            }, 500);
        });

        // Three.js background ‚Äì BlueHound's dreamscape
        const canvas = document.getElementById('bg-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        
        const nodes = [];
        const geometry = new THREE.SphereGeometry(0.08);
        const material = new THREE.MeshBasicMaterial({ color: 0x00aaff });
        for (let i=0; i<50; i++) {
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.x = (Math.random()-0.5)*10;
            sphere.position.y = (Math.random()-0.5)*10;
            sphere.position.z = (Math.random()-0.5)*10;
            scene.add(sphere);
            nodes.push(sphere);
        }
        
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x336699 });
        for (let i=0; i<nodes.length; i+=2) {
            const points = [];
            points.push(nodes[i].position.clone());
            points.push(nodes[i+1]?.position.clone() || nodes[0].position.clone());
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            nodes.forEach((node, i) => {
                node.position.x += Math.sin(Date.now() * 0.001 + i) * 0.002;
                node.position.y += Math.cos(Date.now() * 0.001 + i) * 0.002;
            });
            renderer.render(scene, camera);
        }
        animate();

        // Draggable chat
        const chatModal = document.getElementById('chatModal');
        let pos1=0,pos2=0,pos3=0,pos4=0;
        document.getElementById('chatHeader').onmousedown = (e) => {
            e.preventDefault(); pos3=e.clientX; pos4=e.clientY;
            document.onmouseup = () => { document.onmouseup=null; document.onmousemove=null; };
            document.onmousemove = (e) => {
                e.preventDefault(); pos1=pos3-e.clientX; pos2=pos4-e.clientY; pos3=e.clientX; pos4=e.clientY;
                chatModal.style.top = (chatModal.offsetTop - pos2) + 'px';
                chatModal.style.left = (chatModal.offsetLeft - pos1) + 'px';
            };
        };
    </script>
</body>
</html>
