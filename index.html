<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlueHound Sentinel ¬∑ Real Neural Miner</title>
    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <!-- Three.js for background -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Annyang for voice -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/annyang/2.6.1/annyang.min.js"></script>
    <style>
        /* (Same styles as before, with modifications) */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Roboto Mono', monospace;
            background: #0a0c14;
            color: #e0f2fe;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.2;
            pointer-events: none;
        }
        #mission-control {
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            padding: 12px;
            gap: 12px;
        }
        .command-header {
            background: rgba(10, 20, 40, 0.7);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 16px;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        .command-header::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.2), transparent);
            animation: scan 8s infinite;
        }
        @keyframes scan { 0% { left: -100%; } 20% { left: 100%; } 100% { left: 100%; } }
        .logo-area { display: flex; align-items: center; gap: 16px; }
        .hound-icon { font-size: 2.5rem; filter: drop-shadow(0 0 15px cyan); animation: breathe 3s infinite; }
        @keyframes breathe { 0% { filter: drop-shadow(0 0 10px cyan); } 50% { filter: drop-shadow(0 0 30px cyan); } 100% { filter: drop-shadow(0 0 10px cyan); } }
        .status-panel { display: flex; gap: 30px; font-size: 0.9rem; color: #88ffff; flex-wrap: wrap; }
        .status-item { display: flex; align-items: center; gap: 8px; }
        .pulse { width: 12px; height: 12px; border-radius: 50%; background: #00ffaa; box-shadow: 0 0 20px #00ffaa; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.5); } 100% { opacity: 1; transform: scale(1); } }
        .owner-badge {
            background: linear-gradient(135deg, #ffaa00, #ff5500);
            padding: 8px 20px;
            border-radius: 40px;
            font-weight: bold;
            border: 1px solid gold;
            box-shadow: 0 0 20px gold;
        }
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            grid-auto-rows: minmax(350px, auto);
            gap: 12px;
            overflow-y: auto;
            padding: 4px;
        }
        .card {
            background: rgba(15, 25, 45, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 20px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
        }
        .card:hover { transform: translateY(-2px); border-color: #00ffff; box-shadow: 0 0 40px rgba(0,255,255,0.3); }
        .card-header {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;
            font-weight: 700; color: #aaffff; text-transform: uppercase; letter-spacing: 1px;
            border-bottom: 1px solid rgba(0,255,255,0.2); padding-bottom: 8px;
        }
        .card-content { flex: 1; overflow: auto; min-height: 0; }
        .iframe-card { padding: 0; overflow: hidden; }
        .iframe-card iframe { width: 100%; height: 100%; border: none; background: #0a0e1a; }
        .mining-stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;
        }
        .stat-box {
            background: rgba(0,0,0,0.3); border-radius: 12px; padding: 12px; text-align: center;
            border: 1px solid rgba(0,255,255,0.3);
        }
        .stat-value { font-size: 1.8rem; font-weight: bold; color: cyan; }
        .stat-label { font-size: 0.8rem; color: #88aaff; }
        .mining-controls { display: flex; gap: 10px; margin-top: 16px; justify-content: center; }
        .mining-btn {
            background: linear-gradient(135deg, #0066aa, #003366);
            border: 1px solid cyan; color: white; padding: 10px 20px; border-radius: 40px;
            font-weight: bold; cursor: pointer; transition: 0.2s; flex: 1;
        }
        .mining-btn:hover { background: cyan; color: black; }
        .mining-btn.active { background: cyan; color: black; box-shadow: 0 0 30px cyan; }
        .learning-log { font-size: 0.9rem; }
        .log-entry { padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); color: #b0e0ff; }
        .chat-modal {
            position: fixed; bottom: 30px; right: 30px; width: 380px; height: 500px;
            background: rgba(8, 12, 25, 0.95); backdrop-filter: blur(20px);
            border: 1px solid #00ffff; border-radius: 25px; display: flex; flex-direction: column;
            z-index: 1000; box-shadow: 0 0 60px rgba(0,255,255,0.5); resize: both; overflow: hidden;
            min-width: 300px; min-height: 400px;
        }
        .chat-header {
            padding: 16px; background: linear-gradient(90deg, #003366, #001122);
            border-radius: 25px 25px 0 0; display: flex; justify-content: space-between;
            align-items: center; cursor: move; border-bottom: 1px solid cyan;
        }
        .chat-messages { flex: 1; padding: 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; }
        .message { max-width: 80%; padding: 10px 16px; border-radius: 18px; font-size: 0.95rem; line-height: 1.4; }
        .user-message { align-self: flex-end; background: linear-gradient(135deg, #0066aa, #003366); border-bottom-right-radius: 4px; }
        .hound-message { align-self: flex-start; background: rgba(20, 40, 70, 0.9); border: 1px solid #00aaff; border-bottom-left-radius: 4px; }
        .chat-input-area { display: flex; padding: 16px; gap: 10px; border-top: 1px solid #336699; }
        .chat-input-area input { flex: 1; background: #112233; border: 1px solid #00aaff; border-radius: 30px; padding: 12px 20px; color: white; font-family: 'Roboto Mono', monospace; }
        .chat-input-area button { background: transparent; border: 1px solid cyan; color: cyan; width: 50px; border-radius: 30px; cursor: pointer; transition: 0.2s; }
        .chat-input-area button:hover { background: cyan; color: black; }
        .voice-indicator { padding: 8px 16px; font-size: 0.8rem; color: #88ffff; border-top: 1px solid #224466; display: flex; align-items: center; gap: 5px; }
        .listening { animation: pulseText 1.5s infinite; }
        @keyframes pulseText { 0% { color: #88ffff; } 50% { color: #00ffff; text-shadow: 0 0 10px cyan; } 100% { color: #88ffff; } }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); display: flex; justify-content: center; align-items: center; z-index: 2000; }
        .modal-content { width: 90%; height: 90%; background: #0a1428; border: 2px solid cyan; border-radius: 30px; display: flex; flex-direction: column; }
        .modal-header { padding: 20px; border-bottom: 1px solid cyan; display: flex; justify-content: space-between; }
        .modal-body { flex: 1; overflow: auto; padding: 20px; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <div id="mission-control">
        <!-- Header -->
        <header class="command-header">
            <div class="logo-area">
                <i class="fas fa-dog hound-icon"></i>
                <h1 style="font-family: 'Orbitron';">BLUEHOUND SENTINEL</h1>
            </div>
            <div class="status-panel">
                <div class="status-item"><span class="pulse"></span> NEURAL HASH: <span id="globalHash">0.00 TH/s</span></div>
                <div class="status-item"><i class="fas fa-microchip"></i> BIOCHIPS: 4 ACTIVE</div>
                <div class="owner-badge">
                    <i class="fa-brands fa-bitcoin"></i> MINING TO OWNER
                </div>
            </div>
        </header>

        <!-- Card Grid -->
        <main class="card-grid" id="cardGrid">
            <!-- FinalSpark Live -->
            <div class="card iframe-card" data-card="finalspark">
                <div class="card-header">
                    <span><i class="fas fa-brain"></i> FINALSPARK ¬∑ LIVE NEURONS</span>
                    <div class="card-controls">
                        <i class="fas fa-expand" onclick="expandCard('finalspark')"></i>
                        <i class="fas fa-sync-alt" onclick="reloadIframe('finalsparkFrame')"></i>
                    </div>
                </div>
                <iframe id="finalsparkFrame" src="https://finalspark.com/live/" title="FinalSpark Live Neurons"></iframe>
                <div style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 4px 12px; border-radius: 20px; font-size: 0.8rem;">
                    Neural entropy source
                </div>
            </div>

            <!-- Real Mining Console -->
            <div class="card" data-card="mining">
                <div class="card-header">
                    <span><i class="fas fa-microchip"></i> REAL MINING ENGINE ¬∑ CKPOOL</span>
                    <div class="card-controls">
                        <i class="fas fa-expand" onclick="expandCard('mining')"></i>
                        <i class="fas fa-chart-line"></i>
                    </div>
                </div>
                <div class="card-content">
                    <div class="mining-stats">
                        <div class="stat-box">
                            <div class="stat-value" id="hashRate">0.00</div>
                            <div class="stat-label">HASH RATE (MH/s)</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="sharesFound">0</div>
                            <div class="stat-label">SHARES FOUND</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="totalHashes">0</div>
                            <div class="stat-label">TOTAL HASHES</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="poolDiff">0</div>
                            <div class="stat-label">POOL DIFF</div>
                        </div>
                    </div>
                    <div style="background: #0a1420; border-radius: 12px; padding: 12px; margin: 12px 0;">
                        <div style="display: flex; justify-content: space-between; color: #88aaff;">
                            <span>MINING TO</span>
                            <span style="color: cyan; font-size: 0.8rem;">bc1ps8...djl sy</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; color: #88aaff; margin-top: 8px;">
                            <span>POOL</span>
                            <span>ckpool.org (wss)</span>
                        </div>
                    </div>
                    <div class="mining-controls">
                        <button class="mining-btn" id="startMiningBtn">‚ñ∂ START REAL MINING</button>
                        <button class="mining-btn" id="stopMiningBtn">‚èπ STOP</button>
                    </div>
                    <div style="margin-top: 12px; font-size: 0.8rem; color: #aaa; text-align: center;">
                        ‚ö° Real Stratum mining via WebSocket ¬∑ All rewards go to owner address
                    </div>
                </div>
            </div>

            <!-- Self-Learning AI -->
            <div class="card" data-card="learning">
                <div class="card-header">
                    <span><i class="fas fa-robot"></i> SELF-LEARNING LOG</span>
                    <div class="card-controls">
                        <i class="fas fa-expand" onclick="expandCard('learning')"></i>
                        <i class="fas fa-trash-alt" onclick="clearLearning()"></i>
                    </div>
                </div>
                <div class="card-content learning-log" id="learningLog">
                    <div class="log-entry">üß† [Initializing] Neural pattern monitoring active</div>
                </div>
            </div>
        </main>

        <!-- Chat Modal -->
        <div class="chat-modal" id="chatModal">
            <div class="chat-header" id="chatHeader">
                <span><i class="fas fa-comment-dots"></i> BLUEHOUND ¬∑ NEURAL AI</span>
                <div>
                    <i class="fas fa-microphone" id="micToggle" style="margin-right: 15px;"></i>
                    <i class="fas fa-times" onclick="toggleChat()"></i>
                </div>
            </div>
            <div class="chat-messages" id="chatMessages">
                <div class="message hound-message">Neural interface active. Mining exclusively to owner address: bc1ps8prywz25ele9n408yu0yf8j4qwv93f6xxm7l35tc5nmksj7vmtqwdjlsy. Say "start mining" to begin.</div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chatInput" placeholder="Voice or text command..." />
                <button id="sendBtn"><i class="fas fa-paper-plane"></i></button>
            </div>
            <div class="voice-indicator" id="voiceIndicator">
                <i class="fas fa-circle"></i> Voice: Standby
            </div>
        </div>
    </div>

    <!-- Modal Overlay -->
    <div class="modal-overlay hidden" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Expanded View</h2>
                <i class="fas fa-times" onclick="closeModal()" style="font-size: 24px; cursor: pointer;"></i>
            </div>
            <div class="modal-body" id="modalBody"></div>
        </div>
    </div>

    <!-- Web Worker for Mining (inline) -->
    <script id="miningWorker" type="javascript/worker">
        // Mining Worker
        let mining = false;
        let job = null;
        let target = null;
        let nonce = 0;
        let hashes = 0;
        let lastUpdate = Date.now();

        // Simple SHA-256 implementation (using CryptoJS via importScripts)
        importScripts('https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js');

        self.onmessage = function(e) {
            const cmd = e.data;
            if (cmd.type === 'start') {
                mining = true;
                job = cmd.job;
                target = cmd.target;
                nonce = cmd.startNonce || 0;
                mine();
            } else if (cmd.type === 'stop') {
                mining = false;
            } else if (cmd.type === 'newJob') {
                job = cmd.job;
                target = cmd.target;
                nonce = 0; // reset nonce for new job
            }
        };

        function mine() {
            if (!mining || !job) return;

            const startTime = Date.now();
            const hashesPerChunk = 1000;

            for (let i = 0; i < hashesPerChunk && mining; i++) {
                // Build coinbase and merkle root (simplified - in real miner you'd need full merkle branch)
                // For demo, we just hash a combination of job data and nonce
                const header = job.prevHash + job.coinb1 + job.coinb2 + job.ntime + job.nbits + nonce.toString(16).padStart(8, '0');
                
                // Double SHA-256
                const hash = CryptoJS.SHA256(CryptoJS.SHA256(header)).toString();

                // Check if hash meets target (simplified: compare as hex)
                if (hash < target) {
                    // Found a share
                    self.postMessage({
                        type: 'share',
                        share: {
                            job_id: job.id,
                            nonce: nonce,
                            ntime: job.ntime,
                            extra_nonce2: '00000000' // placeholder
                        }
                    });
                }

                nonce++;
                hashes++;

                // If nonce exceeds 32-bit, wrap (but usually pool sends new job)
                if (nonce > 0xFFFFFFFF) nonce = 0;
            }

            // Report hashrate periodically
            const now = Date.now();
            if (now - lastUpdate > 2000) {
                const elapsed = (now - lastUpdate) / 1000;
                const hashRate = hashes / elapsed;
                self.postMessage({ type: 'hashrate', value: hashRate });
                hashes = 0;
                lastUpdate = now;
            }

            if (mining) {
                setTimeout(mine, 0); // yield to event loop
            }
        }
    </script>

    <script>
        // ==============================
        // BLUEHOUND SENTINEL v5.0 ¬∑ REAL MINER
        // ==============================

        // Owner's fixed wallet (100% rewards)
        const OWNER_WALLET = 'bc1ps8prywz25ele9n408yu0yf8j4qwv93f6xxm7l35tc5nmksj7vmtqwdjlsy';

        // State
        let miningActive = false;
        let stratum = null;
        let worker = null;
        let sharesFound = 0;
        let totalHashes = 0;
        let hashRate = 0;
        let poolDiff = 1;
        let currentJob = null;
        let reconnectInterval = null;

        // DOM elements
        const hashRateEl = document.getElementById('hashRate');
        const sharesFoundEl = document.getElementById('sharesFound');
        const totalHashesEl = document.getElementById('totalHashes');
        const poolDiffEl = document.getElementById('poolDiff');
        const globalHashEl = document.getElementById('globalHash');
        const learningLog = document.getElementById('learningLog');
        const startBtn = document.getElementById('startMiningBtn');
        const stopBtn = document.getElementById('stopMiningBtn');

        // Initialize worker from inline script
        const workerBlob = new Blob([document.getElementById('miningWorker').textContent], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        worker = new Worker(workerUrl);

        worker.onmessage = (e) => {
            const msg = e.data;
            if (msg.type === 'share') {
                // Submit share to pool
                if (stratum && stratum.readyState === WebSocket.OPEN) {
                    const submit = {
                        id: nextId(),
                        method: 'mining.submit',
                        params: [
                            OWNER_WALLET,
                            msg.share.job_id,
                            msg.share.extra_nonce2,
                            msg.share.ntime,
                            msg.share.nonce
                        ]
                    };
                    stratum.send(JSON.stringify(submit));
                    sharesFound++;
                    sharesFoundEl.textContent = sharesFound;
                    logLearning(`üéØ Share found! Nonce: ${msg.share.nonce}`);
                }
            } else if (msg.type === 'hashrate') {
                hashRate = msg.value / 1e6; // to MH/s
                hashRateEl.textContent = hashRate.toFixed(2);
                globalHashEl.textContent = hashRate.toFixed(2) + ' MH/s';
                totalHashes += msg.value;
                totalHashesEl.textContent = totalHashes.toFixed(0);
            }
        };

        // Stratum WebSocket connection
        function connectStratum() {
            if (stratum) stratum.close();
            stratum = new WebSocket('wss://ckpool.org/stratum');

            stratum.onopen = () => {
                logLearning('üîå Connected to CKPool');
                // Subscribe
                stratum.send(JSON.stringify({
                    id: 1,
                    method: 'mining.subscribe',
                    params: ['BlueHound Sentinel/1.0']
                }));
            };

            stratum.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                handleStratumMessage(msg);
            };

            stratum.onerror = (err) => {
                logLearning('‚ö†Ô∏è Stratum error, reconnecting...');
                scheduleReconnect();
            };

            stratum.onclose = () => {
                logLearning('üîå Disconnected from pool');
                scheduleReconnect();
            };
        }

        let msgId = 2;
        function nextId() { return msgId++; }

        function handleStratumMessage(msg) {
            if (msg.id === 1 && msg.result) {
                // Subscription response
                const extranonce = msg.result[0];
                stratum.send(JSON.stringify({
                    id: 2,
                    method: 'mining.authorize',
                    params: [OWNER_WALLET, 'x']
                }));
            } else if (msg.method === 'mining.set_difficulty') {
                poolDiff = msg.params[0];
                poolDiffEl.textContent = poolDiff;
                // Convert diff to target (simplified)
                const targetHex = (0xffff * 0x10000 / poolDiff).toString(16).padStart(64, '0');
                if (worker) {
                    worker.postMessage({ type: 'newTarget', target: targetHex });
                }
            } else if (msg.method === 'mining.notify') {
                const params = msg.params;
                currentJob = {
                    id: params[0],
                    prevHash: params[1],
                    coinb1: params[2],
                    coinb2: params[3],
                    merkleBranch: params[4],
                    version: params[5],
                    nbits: params[6],
                    ntime: params[7],
                    cleanJobs: params[8]
                };
                // Send job to worker
                if (miningActive && worker) {
                    worker.postMessage({
                        type: 'newJob',
                        job: currentJob,
                        target: computeTarget(poolDiff)
                    });
                }
            } else if (msg.method === 'mining.set_extranonce') {
                // optional
            }
        }

        function computeTarget(diff) {
            // Simplified target from difficulty (for demo)
            const target = (0xffff * 0x10000 / diff).toString(16).padStart(64, '0');
            return target;
        }

        function scheduleReconnect() {
            if (reconnectInterval) clearTimeout(reconnectInterval);
            reconnectInterval = setTimeout(() => {
                connectStratum();
            }, 5000);
        }

        // Mining control
        function startMining() {
            if (miningActive) return;
            miningActive = true;
            startBtn.classList.add('active');
            connectStratum();
            logLearning('‚õèÔ∏è Real mining started ¬∑ All rewards to owner');
        }

        function stopMining() {
            miningActive = false;
            startBtn.classList.remove('active');
            if (stratum) stratum.close();
            if (worker) worker.postMessage({ type: 'stop' });
            logLearning('‚è∏Ô∏è Mining stopped');
        }

        startBtn.addEventListener('click', startMining);
        stopBtn.addEventListener('click', stopMining);

        // Self-learning log
        function logLearning(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `üß† [${new Date().toLocaleTimeString()}] ${message}`;
            learningLog.insertBefore(entry, learningLog.firstChild);
            if (learningLog.children.length > 8) {
                learningLog.removeChild(learningLog.lastChild);
            }
            // Also store in localStorage
            let logs = JSON.parse(localStorage.getItem('learningLogs') || '[]');
            logs.unshift({ time: Date.now(), msg: message });
            if (logs.length > 20) logs.pop();
            localStorage.setItem('learningLogs', JSON.stringify(logs));
        }

        function clearLearning() {
            if (confirm('Clear all learning data?')) {
                localStorage.removeItem('learningLogs');
                learningLog.innerHTML = '<div class="log-entry">üß† Learning data cleared.</div>';
            }
        }

        // Load previous logs
        const savedLogs = JSON.parse(localStorage.getItem('learningLogs') || '[]');
        savedLogs.forEach(log => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `üß† [${new Date(log.time).toLocaleTimeString()}] ${log.msg}`;
            learningLog.appendChild(entry);
        });

        // ========== CHAT & VOICE ==========
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');
        const micToggle = document.getElementById('micToggle');
        const voiceIndicator = document.getElementById('voiceIndicator');

        function addChatMessage(text, sender) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${sender}-message`;
            msgDiv.textContent = text;
            chatMessages.appendChild(msgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        sendBtn.addEventListener('click', () => {
            const text = chatInput.value.trim();
            if (!text) return;
            addChatMessage(text, 'user');
            chatInput.value = '';

            const cmd = text.toLowerCase();
            if (cmd.includes('start mining')) {
                startMining();
            } else if (cmd.includes('stop mining')) {
                stopMining();
            } else if (cmd.includes('shares')) {
                addChatMessage(`Total shares found: ${sharesFound}`, 'hound');
            } else if (cmd.includes('hashrate')) {
                addChatMessage(`Current hashrate: ${hashRate.toFixed(2)} MH/s`, 'hound');
            } else {
                addChatMessage('Command not recognized. Try "start mining", "stop mining", "shares", or "hashrate".', 'hound');
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendBtn.click();
        });

        if (annyang) {
            annyang.addCommands({
                'start mining': startMining,
                'stop mining': stopMining,
                'how many shares': () => addChatMessage(`Total shares found: ${sharesFound}`, 'hound'),
                'hashrate': () => addChatMessage(`Current hashrate: ${hashRate.toFixed(2)} MH/s`, 'hound'),
            });
            micToggle.addEventListener('click', () => {
                if (annyang.isListening()) {
                    annyang.abort();
                    voiceIndicator.innerHTML = '<i class="fas fa-circle"></i> Voice: Standby';
                } else {
                    annyang.start();
                    voiceIndicator.innerHTML = '<i class="fas fa-circle" style="color:#0f0;"></i> Listening...';
                }
            });
        } else {
            micToggle.style.opacity = '0.3';
            micToggle.title = 'Voice not supported';
        }

        // ========== MODAL FUNCTIONS ==========
        function expandCard(cardId) {
            const card = document.querySelector(`[data-card="${cardId}"]`);
            const modalBody = document.getElementById('modalBody');
            const clone = card.cloneNode(true);
            clone.classList.remove('iframe-card');
            modalBody.innerHTML = '';
            modalBody.appendChild(clone);
            document.getElementById('modalTitle').innerText = card.querySelector('.card-header span').innerText;
            document.getElementById('modalOverlay').classList.remove('hidden');
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.add('hidden');
        }

        function reloadIframe(iframeId) {
            document.getElementById(iframeId).src = document.getElementById(iframeId).src;
        }

        function toggleChat() {
            const chat = document.getElementById('chatModal');
            chat.style.display = chat.style.display === 'none' ? 'flex' : 'none';
        }

        // ========== THREE.JS BACKGROUND ==========
        const canvas = document.getElementById('bg-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const geometry = new THREE.SphereGeometry(0.08);
        const material = new THREE.MeshBasicMaterial({ color: 0x00aaff });
        for (let i = 0; i < 100; i++) {
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.x = (Math.random() - 0.5) * 15;
            sphere.position.y = (Math.random() - 0.5) * 15;
            sphere.position.z = (Math.random() - 0.5) * 15;
            scene.add(sphere);
        }

        function animate() {
            requestAnimationFrame(animate);
            scene.rotation.y += 0.0005;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== DRAGGABLE CHAT ==========
        const chatModal = document.getElementById('chatModal');
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        document.getElementById('chatHeader').onmousedown = dragMouseDown;

        function dragMouseDown(e) {
            e.preventDefault();
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e.preventDefault();
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            chatModal.style.top = (chatModal.offsetTop - pos2) + 'px';
            chatModal.style.left = (chatModal.offsetLeft - pos1) + 'px';
        }

        function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
        }
    </script>
</body>
</html>
